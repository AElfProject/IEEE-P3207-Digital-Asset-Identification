/**
 * Summary
 * This standard aims to define the data structure and data format related to asset identification, so as to improve the efficiency of digital asset management in the blockchain system. The standard data structure can provide guidance for the design of digital asset management solutions, and use the standardized data format to provide a reference for building a digital asset service platform.
 * Purpose
 * Digital asset management is a key component of the blockchain ecosystem. However, in the field of blockchain, there are currently no standards related to digital asset identification.
 * 1. Due to the lack of common specifications, different assets may be based on different protocol frameworks, and multi-asset management becomes extremely complicated. This standard aims to provide a common framework and specifications for multi-asset management.
 * 2. When it comes to certain cross-chain related scenarios, the universal asset identification method becomes more important. Without such a set of specifications, the compatibility problem between blockchain systems will be difficult to solve. This standard aims to Propose a cross-chain asset management specification compatible with blockchain.
 * Specification
 * The keywords "must", "need", "should", "should be prohibited", "should not", "recommended", "may" and "optional" in this document are in accordance with RFC 2119 Description to explain.
 */

syntax = "proto3";
import "google/protobuf/descriptor.proto";
package token;

// All custom options field numbers are like 50yxxx
// where y stands for the custom options type:
// 0 - FileOptions
// 1 - MessageOptions
// 2 - FieldOptions
// 3 - EnumOptions
// 4 - EnumValueOptions
// 5 - ServiceOptions
// 6 - MethodOptions
extend google.protobuf.FileOptions {
    string identity = 500001;
}

extend google.protobuf.ServiceOptions {
    repeated string base = 505001;
    string csharp_state = 505030;
}

extend google.protobuf.MethodOptions {
    bool is_view = 506001;
}

extend google.protobuf.MessageOptions {
    bool is_event = 50100;
}

extend google.protobuf.FieldOptions {
    bool is_indexed = 502001;
}

service TokenContract {
    // Create a new token.
    rpc Create (CreateInput) returns (Empty) {
    }
    
    // Issuing some amount of tokens to an address is the action of increasing that addresses balance 
    // for the given token. The total amount of issued tokens must not exceed the total supply of the token 
    // and only the issuer (creator) of the token can issue tokens. 
    // Issuing tokens effectively increases the circulating supply.
    rpc Issue (IssueInput) returns (Empty) {
    }
    
    // Transferring tokens simply is the action of transferring a given amount of tokens from one address to another. 
    // The origin or source address is the signer of the transaction. 
    // The balance of the sender must be higher than the amount that is transferred.
    rpc Transfer (TransferInput) returns (Empty) {
    }
    
    // The TransferFrom action will transfer a specified amount of tokens from one address to another. 
    // For this operation to succeed the from address needs to have approved (see allowances) enough tokens 
    // to Sender of this transaction. If successful the amount will be removed from the allowance.
    rpc TransferFrom (TransferFromInput) returns (Empty) {
    }

    // The BatchTransferFrom action will transfer a batch of specified amount of tokens from one address to another. 
    // For this operation to succeed the from address needs to have approved (see allowances) enough tokens 
    // to Sender of this transaction. If successful the amount will be removed from the allowance.
    rpc BatchTransferFrom (BatchTransferFromInput) returns (Empty) {
    }

    // The approve action increases the allowance from the Sender to the Spender address, 
    // enabling the Spender to call TransferFrom.
    rpc Approve (ApproveInput) returns (Empty) {
    }
    
    // This is the reverse operation for Approve, it will decrease the allowance.
    rpc UnApprove (UnApproveInput) returns (Empty) {
    }
    
    // This method can be used to lock tokens.
    rpc Lock (LockInput) returns (Empty) {
    }
    
    // This is the reverse operation of locking, it un-locks some previously locked tokens.
    rpc Unlock (UnlockInput) returns (Empty) {
    }
    
    // This action will burn the specified amount of tokens, removing them from the tokenâ€™s Supply.
    rpc Burn (BurnInput) returns (Empty) {
    }
    
    // Change the issuer of the specified token. Only the original issuer can change it.
    rpc ChangeTokenIssuer (ChangeTokenIssuerInput) returns (Empty) {
    }

    // Set the primary token of side chain.
    rpc SetPrimaryTokenSymbol (SetPrimaryTokenSymbolInput) returns (Empty) {
    }
    
    // This interface is used for cross-chain transfer.
    rpc CrossChainTransfer (CrossChainTransferInput) returns (Empty) {
    }
    
    // This method is used to receive cross-chain transfers.
    rpc CrossChainReceiveToken (CrossChainReceiveTokenInput) returns (Empty) {
    }
    
    // The side chain creates tokens.
    rpc CrossChainCreateToken(CrossChainCreateTokenInput) returns (Empty) {        
    }
    
    // When the side chain is started, the side chain is initialized with the parent chain information.
    rpc InitializeFromParentChain (InitializeFromParentChainInput) returns (Empty) {
    }

    // Handle the transaction fees charged by ChargeTransactionFees.
    rpc ClaimTransactionFees (TotalTransactionFeesMap) returns (Empty) {
    }
    
    // Used to collect transaction fees.
    rpc ChargeTransactionFees (ChargeTransactionFeesInput) returns (ChargeTransactionFeesOutput) {
    }

    // Check the token threshold.
    rpc CheckThreshold (CheckThresholdInput) returns (Empty) {
    }

    // Initialize coefficients of every type of tokens supporting charging fee.
    rpc InitialCoefficients (Empty) returns (Empty){
    }
    
    // Processing resource token received.
    rpc DonateResourceToken (TotalResourceTokensMaps) returns (Empty) {
    }
    
    // A transaction resource fee is charged to implement the ACS8 standards.
    rpc ChargeResourceToken (ChargeResourceTokenInput) returns (Empty) {
    }
    
    // Verify that the resource token are sufficient.
    rpc CheckResourceToken (Empty) returns (Empty) {
    }
    
    // Set the list of tokens to pay transaction fees.
    rpc SetSymbolsToPayTxSizeFee (SymbolListToPayTxSizeFee) returns (Empty){
    }
    
    // Update the coefficient of the transaction fee calculation formula.
    rpc UpdateCoefficientsForSender (UpdateCoefficientsInput) returns (Empty) {
    }
    
    // Update the coefficient of the transaction fee calculation formula.
    rpc UpdateCoefficientsForContract (UpdateCoefficientsInput) returns (Empty) {
    }
    
    // This method is used to initialize the governance organization for some functions, 
    // including: the coefficient of the user transaction fee calculation formula, 
    // the coefficient of the contract developer resource fee calculation formula, and the side chain rental fee.
    rpc InitializeAuthorizedController(Empty) returns (Empty){
    }

    // Query token information.
    rpc GetTokenInfo (GetTokenInfoInput) returns (TokenInfo) {
        option (is_view) = true;
    }
    
    // Query native token information.
    rpc GetNativeTokenInfo (Empty) returns (TokenInfo) {
        option (is_view) = true;
    }
    
    // Query resource token information.
    rpc GetResourceTokenInfo (Empty) returns (TokenInfoList) {
        option (is_view) = true;
    }
    
    // Query the balance at the specified address.
    rpc GetBalance (GetBalanceInput) returns (GetBalanceOutput) {
        option (is_view) = true;
    }

    // Batch query the balance at the specified address.
    rpc GetBalanceBatch (GetBalanceBatchInput) returns (GetBalanceBatchOutput) {
    option (is_view) = true;
        }

    // Query the account's allowance for other addresses
    rpc GetAllowance (GetAllowanceInput) returns (GetAllowanceOutput) {
        option (is_view) = true;
    }
    
    // Check whether the token is in the whitelist of an address, 
    // which can be called TransferFrom to transfer the token under the condition of not being credited.
    rpc IsInWhiteList (IsInWhiteListInput) returns (BoolValue) {
        option (is_view) = true;
    }
    
    // Query the information for a lock.
    rpc GetLockedAmount (GetLockedAmountInput) returns (GetLockedAmountOutput) {
        option (is_view) = true;
    }
    
    // Query the address of receiving token in cross-chain transfer.
    rpc GetCrossChainTransferTokenContractAddress (GetCrossChainTransferTokenContractAddressInput) returns (Address) {
        option (is_view) = true;
    }
    
    // Query the name of the primary Token.
    rpc GetPrimaryTokenSymbol (Empty) returns (StringValue) {
        option (is_view) = true;
    }
    
    // Query the coefficient of the transaction fee calculation formula.
    rpc GetCalculateFeeCoefficientsForContract (Int32Value) returns (CalculateFeeCoefficients) {
        option (is_view) = true;
    }

    // Query the coefficient of the transaction fee calculation formula.
    rpc GetCalculateFeeCoefficientsForSender (Empty) returns (CalculateFeeCoefficients) {
        option (is_view) = true;
    }
    
    // Query tokens that can pay transaction fees.
    rpc GetSymbolsToPayTxSizeFee (Empty) returns (SymbolListToPayTxSizeFee){
        option (is_view) = true;
    }
    
    // Query the hash of the last input of ClaimTransactionFees.
    rpc GetLatestTotalTransactionFeesMapHash (Empty) returns (Hash){
        option (is_view) = true;
    }
    
    // Query the hash of the last input of DonateResourceToken.
    rpc GetLatestTotalResourceTokensMapsHash (Empty) returns (Hash){
        option (is_view) = true;
    }
    rpc IsTokenAvailableForMethodFee (StringValue) returns (BoolValue) {
        option (is_view) = true;
    }

    // This interface is used for batch cross-chain transfer.
    rpc CrossChainTransferBatch (CrossChainTransferBatchInput) returns (Empty) {
    }
}

// The information of token.
// Output parameters:
// symbol, token_name, supply, total_supply, decimals, issuer, is_burnable, issue_chain_id, issued, external_information.
message TokenInfo {
    // The symbol of the token.
    string symbol = 1;
    // The full name of the token.
    string token_name = 2;
    // The current supply of the token.
    int64 supply = 3;
    // The total supply of the token.
    int64 total_supply = 4;
    // The precision of the token.
    int32 decimals = 5;
    // The address that created the token.
    Address issuer = 6;
    // A flag indicating if this token is burnable.
    bool is_burnable = 7;
    // The chain id of the token.
    int32 issue_chain_id = 8;
    // The amount of issued tokens.
    int64 issued = 9;
    // The external information.
    map<string, string> external_information = 10;
}

// The function of creating a token.
// Input parameters:
// symbol, token_name, supply, total_supply, decimals, issuer, is_burnable, issue_chain_id, issued, external_information.
message CreateInput {
    // The symbol of the token.
    string symbol = 1;
    // The full name of the token.
    string token_name = 2;
    // The total supply of the token.
    int64 total_supply = 3;
    // The precision of the token.
    int32 decimals = 4;
    // The address that created the token.
    Address issuer = 5;
    // A flag indicating if this token is burnable.
    bool is_burnable = 6;
    // A whitelist address list used to lock tokens.
    repeated Address lock_white_list = 7;
    // The chain id of the token.
    int32 issue_chain_id = 8;
    // The external information.
    map<string, string> external_information = 9;
}

// The function of setting the primary token of side chain.
// Input parameters:
// symbol.
message SetPrimaryTokenSymbolInput {
    // The symbol of the token.
    string symbol = 1;
}

// The function of issuing some amount of tokens to an address. 
// Input parameters:
// symbol, amount, to, memo.
message IssueInput {
    // The token symbol to issue.
    string symbol = 1;
    // The token amount to issue.
    int64 amount = 2;
    // The memo.
    string memo = 3;
    // The target address to issue.
    Address to = 4;
}

// The function of transferring a given amount of tokens from one address to another. 
// Input parameters:
// to, symbol, amount, memo.
message TransferInput {
    // The receiver of the token.
    Address to = 1;
    // The token symbol to transfer.
    string symbol = 2;
    // The amount to to transfer.
    int64 amount = 3;
    // The memo.
    string memo = 4;
}

// The function of locking tokens.
// Input parameters:
// lock_address, lock_id, symbol, amount, memo.
message LockInput {
    // The one want to lock his token.
    Address address = 1; 
    // Id of the lock.
    Hash lock_id = 2;
    // The symbol of the token to lock.
    string symbol = 3;
    // a memo.
    string memo = 4;
    // The amount of tokens to lock.
    int64 amount = 5;
}

// The function of unlocking tokens.
// Input parameters:
// unlock_address, lock_id, symbol, amount, memo.
message UnlockInput {
    // The one want to un-lock his token.
    Address address = 1;
    // Id of the lock.
    Hash lock_id = 2;
    // The symbol of the token to un-lock.
    string symbol = 3;
    // a memo.
    string memo = 4;
    // The amount of tokens to un-lock.
    int64 amount = 5;
}

// The function of transfering a specified amount of tokens from one address to another. 
// Input parameters:
// from, to, symbol, amount, memo.
message TransferFromInput {
    // The source address of the token.
    Address from = 1;
    // The destination address of the token.
    Address to = 2;
    // The symbol of the token to transfer.
    string symbol = 3;
    // The amount to transfer.
    int64 amount = 4;
    // The memo.
    string memo = 5;
}

// The function of increasing the allowance from the Sender to the Spender address, 
// Input parameters:
// spender, symbol, amount.
message ApproveInput {
    // The address that allowance will be increased. 
    Address spender = 1;
    // The symbol of token to approve.
    string symbol = 2;
    // The amount of token to approve.
    int64 amount = 3;
}

// The function of increasing the allowance of all one's tokens from the Sender to the Spender address, 
// Input parameters:
// spender, symbol.
message ApproveForAllInput{
    // The address of an account/contract that is approved to make the operate.
    Address spender = 1;
    // The symbol of token to approve.
    string symbol = 2;
    }    
    
// The function of reversing operation for Approve, it will decrease the allowance.
// Input parameters:
// spender, symbol, amount.
message UnApproveInput {
    // The address that allowance will be decreased. 
    Address spender = 1;
    // The symbol of token to un-approve.
    string symbol = 2;
    // The amount of token to un-approve.
    int64 amount = 3;
}

// The function of burning the specified amount of tokens, removing them from the tokenâ€™s Supply.
// Input parameters:
// symbol, amount, memo.
message BurnInput {
    // The symbol of token to burn.
    string symbol = 1;
    // The amount of token to burn.
    int64 amount = 2;
}

// The function of charging a transaction resource fee(Implemented from the ACS8 standards).
// Input parameters:
// cost_dic, caller.
message ChargeResourceTokenInput {
    // Collection of charge resource token, Symbol->Amount.
    map<string, int64> cost_dic = 1;
    // The sender of the transaction.
    Address caller = 2;
}

// The function of charging a transaction resource fee(Implemented from the ACS8 standards).
// Input parameters:
// fees_map.
message TransactionFeeBill {
    // The transaction fee dictionary, Symbol->fee.
    map<string, int64> fees_map = 1;
}

// The function of checking the token threshold.
// Input parameters:
// sender, symbol_to_threshold, is_check_allowance.
message CheckThresholdInput {
    // The sender of the transaction.
    Address sender = 1;
    // The threshold to set, Symbol->Threshold.
    map<string, int64> symbol_to_threshold = 2;
    // Whether to check the allowance.
    bool is_check_allowance = 3;
}

// The function of querying token information.
// Input parameters:
// symbol.
message GetTokenInfoInput {
    // The symbol of token.
    string symbol = 1;
}

// The function of querying the balance at the specified address.
// Input parameters:
// symbol, owner.
message GetBalanceInput {
    // The symbol of token.
    string symbol = 1;
    // The target address of the query.
    Address owner = 2;
}

// The output of querying the balance at the specified address.
// Output parameters:
// symbol, owner, balance.
message GetBalanceOutput {
    // The symbol of token.
    string symbol = 1;
    // The target address of the query.
    Address owner = 2;
    // The balance of the owner.
    int64 balance = 3;
}

// The function of batch querying the balance at the specified address.
// Input parameters:
// symbol, owner.
message GetBalanceBatchInput {
    // The symbol of token.
    repeated string symbol = 1;
    // The target address of the query.
    Address owner = 2;
    }
    
// The output of batch querying the balance at the specified address.
// Output parameters:
// symbol, owner, balance.
message GetBalanceBatchOutput {
    // The symbol of token.
    repeated string symbol = 1;
    // The target address of the query.
    Address owner = 2;
    // The balance of the owner.
    repeated int64 balance = 3;
    }
    
// The funciton of querying the account's allowance for other addresses.
// Input parameters:
// symbol, owner, spender.
message GetAllowanceInput {
    // The symbol of token.
    string symbol = 1;
    // The address of the token owner.
    Address owner = 2;
    // The address of the spender.
    Address spender = 3;
}

// The output of querying the account's allowance for other addresses.
// Out parameters:
// symbol, owner, spender, allowance.
message GetAllowanceOutput {
    // The symbol of token.
    string symbol = 1;
    // The address of the token owner.
    Address owner = 2;
    // The address of the spender.
    Address spender = 3;
    // The amount of allowance.
    int64 allowance = 4;
}

// The function of cross-chain transfering.
// Input parameters:
// to, symbol, amount, memo, to_chain_id, issue_chain_id.
message CrossChainTransferInput {
    // The receiver of transfer.
    Address to = 1;
    // The symbol of token.
    string symbol = 2;
    // The amount of token to transfer.
    int64 amount = 3;
    // The memo.
    string memo = 4;
    // The destination chain id.
    int32 to_chain_id = 5;
    // The chain id of the token.
    int32 issue_chain_id = 6;
}
// The function of receiving cross-chain transfers.
// Input parameters:
// from_chain_id, parent_chain_height, transfer_transaction_bytes, merkle_path
message CrossChainReceiveTokenInput {
    // The source chain id.
    int32 from_chain_id = 1;
    // The height of the transfer transaction.
    int64 parent_chain_height = 2;
    // The raw bytes of the transfer transaction.
    bytes transfer_transaction_bytes = 3;
    // The merkle path created from the transfer transaction.
    MerklePath merkle_path = 4;
}

// The functio of checking whether the token is in the whitelist of an address, which can be called TransferFrom to transfer the token under the condition of not being credited.
// Input parameters:
// symbol, address.
message IsInWhiteListInput {
    // The symbol of token. 
    string symbol = 1;
    // The address to check.
    Address address = 2;
}

// The function of transaction fee weight calculation.
// Input parameters:
// token_symbol, base_token_weight, added_token_weight.
message SymbolToPayTxSizeFee{
    // The symbol of token. 
    string token_symbol = 1;
    // The charge weight of primary token.
    int32 base_token_weight = 2;
    // The new added token charge weight. For example, the charge weight of primary Token is set to 1. 
    // The newly added token charge weight is set to 10. If the transaction requires 1 unit of primary token, 
    // the user can also pay for 10 newly added tokens.
    int32 added_token_weight = 3;
}

// The function of transaction fee weight calculation(list).
// Input parameters:
// symbols_to_pay_tx_size_fee.
message SymbolListToPayTxSizeFee{
    // Transaction fee token information.
    repeated SymbolToPayTxSizeFee symbols_to_pay_tx_size_fee = 1;
}

// The function of collecting transaction fees.
// Input parameters:
// method_name, contract_address, contract_address, symbols_to_pay_tx_size_fee.
message ChargeTransactionFeesInput {
    // The method name of transaction.
    string method_name = 1;
    // The contract address of transaction.
    Address contract_address = 2;
    // The amount of transaction size fee.
    int64 transaction_size_fee = 3;
    // Transaction fee token information.
    repeated SymbolToPayTxSizeFee symbols_to_pay_tx_size_fee = 4;
}

// The output of collecting transaction fees.
// Output parameters:
// success, charging_information.
message ChargeTransactionFeesOutput {
    // Whether the charge was successful.
    bool success = 1;
    // The charging information.
    string charging_information = 2;
}

// The event of token lift modified.
// Input parameters:
// symbol_list_to_pay_tx_size_fee.
message ExtraTokenListModified {
    option (is_event) = true;
    // Transaction fee token information.
    SymbolListToPayTxSizeFee symbol_list_to_pay_tx_size_fee = 1;
}

// The function of querying the information for a lock.
// Input parameters:
// address, symbol, lock_id. 
message GetLockedAmountInput {
    // The address of the lock.
    Address address = 1;
    // The token symbol.
    string symbol = 2;
    // The id of the lock.
    Hash lock_id = 3;
}

// The output of querying the information for a lock.
// Input parameters:
// address, symbol, lock_id, amount. 
message GetLockedAmountOutput {
    // The address of the lock.
    Address address = 1;
    // The token symbol.
    string symbol = 2;
    // The id of the lock.
    Hash lock_id = 3;
    // The locked amount.
    int64 amount = 4;
}

// The output of tokeninfo(list).
// Output parameters:
// value
message TokenInfoList {
    // List of token information.
    repeated TokenInfo value = 1;
}

// The function of querying the address of receiving token in cross-chain transfer.
// Input parameters:
// chain_id.
message GetCrossChainTransferTokenContractAddressInput {
    // The chain id.
    int32 chainId = 1;
}

// The function of creating tokens on side chain.
// Input parameters:
// from_chain_id, parent_chain_height, transaction_bytes, merkle_path.
message CrossChainCreateTokenInput {
    // The chain id of the chain on which the token was created.
    int32 from_chain_id = 1;
    // The height of the transaction that created the token.
    int64 parent_chain_height = 2;
    // The transaction that created the token.
    bytes transaction_bytes = 3;
    // The merkle path created from the transaction that created the transaction.
    MerklePath merkle_path = 4;
}

// The function of initializing side chain with the parent chain's information, when the side chain is start.
// Input parameters:
// resource_amount, registered_other_token_contract_addresses, creator.
message InitializeFromParentChainInput {
    // The amount of resource.
    map<string, int32> resource_amount = 1;
    // The token contract addresses.
    map<int32, Address> registered_other_token_contract_addresses = 2;
    // The creator the side chain.
    Address creator = 3;
}

// The function of updating the coefficient of the transaction fee calculation formula.
// Input parameters:
// piece_numbers, coefficients.
message UpdateCoefficientsInput {
    // The specify pieces gonna update.
    repeated int32 piece_numbers = 1;
    // Coefficients of one single type.
    CalculateFeeCoefficients coefficients = 2;
}

enum FeeTypeEnum {
    READ = 0;
    STORAGE = 1;
    WRITE = 2;
    TRAFFIC = 3;
    TX = 4;
}

// The function of Calculating piece fees.
// Output parameters:
// value.
message CalculateFeePieceCoefficients {
    // Coefficients of one single piece.
    // The first char is its type: liner / power.
    // The second char is its piece upper bound.
    repeated int32 value = 1;
}

// The function of Calculating fees.
// Output parameters:
// fee_token_type, piece_coefficients_list.
message CalculateFeeCoefficients {
    // The resource fee type, like READ, WRITE, etc.
    int32 fee_token_type = 1;
    // Coefficients of one single piece.
    repeated CalculateFeePieceCoefficients piece_coefficients_list = 2;
}

// The function of Calculating all fees.
// Output parameters:
// value.
message AllCalculateFeeCoefficients {
    // The coefficients of fee Calculation.
    repeated CalculateFeeCoefficients value = 1;
}

// The functioon of handling the transaction fees charged by ChargeTransactionFees.
// Output parameters:
// value, block_hash, block_height.
message TotalTransactionFeesMap
{
    // Token dictionary that charge transaction fee, Symbol->Amount.
    map<string, int64> value = 1;
    // The hash of the block processing the transaction.
    Hash block_hash = 2;
    // The height of the block processing the transaction.
    int64 block_height = 3;
}

// The function of processing resource token received.
// Output parameters:
// value, block_hash, block_hash.
message TotalResourceTokensMaps {
    // Resource tokens to charge.
    repeated ContractTotalResourceTokens value = 1;
    // The hash of the block processing the transaction.
    Hash block_hash = 2;
    // The height of the block processing the transaction.
    int64 block_height = 3;
}

// The function of resource tokens to charge.
// Input parameters:
// contract_address, tokens_map.
message ContractTotalResourceTokens {
    // The contract address.
    Address contract_address = 1;
    // Resource tokens to charge.
    TotalResourceTokensMap tokens_map = 2;
}

// The function of processing resource token received.
// Output parameters:
// value.
message TotalResourceTokensMap
{
    // Resource token dictionary, Symbol->Amount.
    map<string, int64> value = 1;
}

// The function of changing the issuer of the specified token.
// Input parameters:
// symbol, new_token_issuer.
message ChangeTokenIssuerInput
{
    // The token symbol.
    string symbol = 1;
    // The new token issuer for change.
    Address new_token_issuer = 2;
}

// The event of transfering tokens.
// Input parameters:
// from, to, symbol, amount, memo.
message Transferred {
    option (is_event) = true;
    // The source address of the transferred token.
    Address from = 1 [(is_indexed) = true];
    // The destination address of the transferred token.
    Address to = 2 [(is_indexed) = true];
    // The symbol of the transferred token.
    string symbol = 3 [(is_indexed) = true];
    // The amount of the transferred token.
    int64 amount = 4;
    // The memo.
    string memo = 5;
}
    
// The event of increasing the allowance from the Sender to the Spender address.
// Input parameters:
// owner, spender, symbol, amount.
message Approved {
    option (is_event) = true;
    // The address of the token owner.
    Address owner = 1 [(is_indexed) = true];
    // The address that allowance be increased. 
    Address spender = 2 [(is_indexed) = true];
    // The symbol of approved token.
    string symbol = 3 [(is_indexed) = true];
    // The amount of approved token.
    int64 amount = 4;
}

// The event of reversing operation for Approve, it will decrease the allowance.
// Input parameters:
// owner, spender, symbol, amount.
message UnApproved {
    option (is_event) = true;
    // The address of the token owner.
    Address owner = 1 [(is_indexed) = true];
    // The address that allowance be decreased. 
    Address spender = 2 [(is_indexed) = true];
    // The symbol of un-approved token.
    string symbol = 3 [(is_indexed) = true];
    // The amount of un-approved token.
    int64 amount = 4;
}

// The event of burning the specified amount of tokens, removing them from the tokenâ€™s Supply.
// Input parameters:
// burner, symbol, amount.
message Burned
{
    option (is_event) = true;
    // The address who wants to burn token.
    Address burner = 1 [(is_indexed) = true];
    // The symbol of burned token. 
    string symbol = 2 [(is_indexed) = true];
    // The amount of burned token. 
    int64 amount = 3;
}

// The event of setting primary token.
// Input parameters:
// token_symbol.
message ChainPrimaryTokenSymbolSet {
    option (is_event) = true;
    // The symbol of token. 
    string token_symbol = 1;
}

// The event of updating calculate fee algorithm.
// Input parameters:
// all_type_fee_coefficients.
message CalculateFeeAlgorithmUpdated {
    option (is_event) = true;
    // All calculate fee coefficients after modification.
    AllCalculateFeeCoefficients all_type_fee_coefficients = 1;
}

// The event of charging rental fee.
// Input parameters:
// symbol, amount.
message RentalCharged {
    option (is_event) = true;
    // The symbol of rental fee charged.
    string symbol = 1;
    // The amount of rental fee charged.
    int64 amount = 2;
}

// The event of charging rental fee(which is insufficient).
// Input parameters:
// symbol, amount.
message RentalAccountBalanceInsufficient {
    option (is_event) = true;
    // The symbol of insufficient rental account balance.
    string symbol = 1;
    // The balance of the account.
    int64 amount = 2;
}

// The event of creating token.
// Input parameters:
// symbol, token_name, total_supply, decimals, issuer, is_burnable, issue_chain_id, external information..
message TokenCreated {
    option (is_event) = true;
    // The symbol of the token.
    string symbol = 1;
    // The full name of the token.
    string token_name = 2;
    // The total supply of the token.
    int64 total_supply = 3;
    // The precision of the token.
    int32 decimals = 4;
    // The address that created the token.
    Address issuer = 5;
    // A flag indicating if this token is burnable.
    bool is_burnable = 6;
    // The chain id of the token.
    int32 issue_chain_id = 7;
    // The external information.
    map<string, string> external_information = 8;
}

// The event of issuing token.
// Input parameters:
// symbol, amount, memo, to.
message Issued {
    option (is_event) = true;
    // The symbol of issued token.
    string symbol = 1;
    // The amount of issued token.
    int64 amount = 2;
    // The memo.
    string memo = 3;
    // The issued target address.
    Address to = 4;
}

// The function of querying the total supply of the token.
// Input parameters:
// owner, symbol, amount, memo.
message TotalSupply{
    // The owner who issued the token.
    Address owner = 1;
    // The symbol of the transferred token.
    string symbol = 2;
    // The amount of the transferred token.
    int64 amount = 3;
    // The memo.
    string memo = 4;
}

// The event of transfering tokens(cross-chain).
// Input parameters:
// from, to, symbol, amount, to_chain_id, issue_chain_id, memo.
message CrossChainTransferred {
    option (is_event) = true;
    // The source address of the transferred token.
    Address from = 1;
    // The destination address of the transferred token.
    Address to = 2;
    // The symbol of the transferred token.
    string symbol = 3;
    // The amount of the transferred token.
    int64 amount = 4;
    // The destination chain id.
    int32 to_chain_id = 5;
    // The chain id of the token.
    int32 issue_chain_id = 6;
    // The memo.
    string memo = 7;
}

// The event of receiving the token(cross-chain).
// Input parameters:
// from, to, symbol, amount, memo, from_chain_id, issue_chain_id, parent_chain_height.
message CrossChainReceived {
    option (is_event) = true;
    // The source address of the transferred token.
    Address from = 1;
    // The destination address of the transferred token.
    Address to = 2;
    // The symbol of the received token.
    string symbol = 3;
    // The amount of the received token.
    int64 amount = 4;
    // The memo.
    string memo = 5;
    // The destination chain id.
    int32 from_chain_id = 6;
    // The chain id of the token.
    int32 issue_chain_id = 7;
    // The parent chain height of the transfer transaction.
    int64 parent_chain_height = 8;
}

// The event of batch receiving the token(cross-chain).
// Input parameters:
// from, to, symbol, amount, from_chain_id, issue_chain_id, parent_chain_height.
message CrossChainBatchReceived {
    option (is_event) = true;
    // The source address of the transferred token.
    Address from = 1;
    // The destination address of the transferred token.
    Address to = 2;
    // The symbol of the received token.
    repeated string symbol = 3;
    // The amount of the received token.
    repeated int64 amount = 4;
    // The destination chain id.
    int32 from_chain_id = 5;
    // The chain id of the token.
    int32 issue_chain_id = 6;
    // The parent chain height of the transfer transaction.
    int64 parent_chain_height = 7;
}

// The event of transfering the token.
// Input parameters:
// from, to, symbol, amount.
message TransferredBatch {
    option (is_event) = true;
    // The source address of the transferred token.
    Address from = 1 [(is_indexed) = true];
    // The destination address of the transferred token.
    Address to = 2 [(is_indexed) = true];
    // The symbol of the transferred token.
    repeated string symbol = 3 [(is_indexed) = true];
    // The amount of the transferred token.
    repeated int64 amount = 4;
}
    
// The event of batch transfering the token(cross-chain).
// Input parameters:
// from, to, symbol, amount, to_issue_chain_id, issue_chain_id.
message CrossChainTransferredBatch {
    option (is_event) = true;
    // The source address of the transferred token.
    Address from = 1;
    // The destination address of the transferred token.
    Address to = 2;
    // The symbol of the transferred token.
    repeated string symbol = 3;
    // The amount of the transferred token.
    repeated int64 amount = 4;
    // The destination chain id.
    int32 to_chain_id = 5;
    // The chain id of the token.
    int32 issue_chain_id = 6;
}
    
// The event of showing infomation of the changed token.
// Input parameters:
// symbol, amount.
message URI {
    option (is_event) = true;
    // The symbol of issued token.
    string symbol = 1;
    // The amount of issued token.
    int64 amount = 2;
}
    
// The function of batch transfering(cross-chain).
// Input parameters:
// from, to, symbol, amount, to_chain_id, issue_chain_id, memo.
message CrossChainTransferBatchInput {
    // The signer of the transaction.
    Address from = 1;
    // The receiver of transfer.
    Address to = 2;
    // The symbol of token.
    repeated string symbol = 3;
    // The amount of token to transfer.
    repeated int64 amount = 4;
    // The destination chain id.
    int32 to_chain_id = 5;
    // The chain id of the token.
    int32 issue_chain_id = 6;
    // The memo.
    string memo = 7;
}
    
// The function of batch transfering form.
// Input parameters:
// from, to, symbol, amount, memo.
message BatchTransferFromInput {
    // The source address of the token.
    Address from = 1;
    // The destination address of the token.
    Address to = 2;
    // The symbol of the token to transfer.
    repeated string symbol = 3;
    // The amount to transfer.
    repeated int64 amount = 4;
    // The memo.
    string memo = 6;
}

// The function of empty return.
// Output parameters:
// empty.
message Empty {
    // Empty return.
    string empty = 1;
}
    
// The function of hash return.
// Output parameters:
// hash.
message Hash {
    // Hash value.
    string hash = 1;
}
     
// The function of address return.
// Output parameters:
// address.
message Address {
    // Address.
    string address = 1;
}
    
// The function of Int32Value return.
// Output parameters:
// int_value.
message Int32Value {
    // Int32 value.
    int32 int_value = 1;    
}
    
// The function of StringValue return.
// Output parameters:
// string_value.
message StringValue {
    // String value.
    string string_value = 1;   
}
    
// The function of BoolValue return.
// Output parameters:
// bool_value.
message BoolValue {
    // Bool value.
    bool bool_value = 1;  
}
    
// The function of merklePath return.
// Output parameters:
// merkle_path.
message MerklePath {
    //Merkle path.
    string merkle_path = 1;
}